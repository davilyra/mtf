%{
PostProcessStressData.m

Last updated by Davi and Jeff: 04/22/2019
adapted from the original code by Pat Alford and Anya Grosberg
Laboratory for Living Systems Engineering
Viterbi School of Engineering
University of Southern California, Los Angeles, CA 90089

Last updated by Anya: 02/04/2010

adapted from the code by Pat Alfred by Anya Grosberg
Disease Biophysics Group
School of Engineering and Applied Sciences
Havard University, Cambridge, MA 02138

The purpose of this code is to analyze the stress data generated by FilmStressCalcMain...

Input:
    The user is aksed for:
        1. File containing all the stress data

Output: 1. Plots showing all the stress and the fits
        2. peak contraction stress, basal, normalized stress, rise & fall time etc --> saved to file
%}

clear all

%ask for the file with the stress data
[fileX,pathX] = uigetfile({'*.mat';'*.*'},'Select the stress data file...','G:\Anya\Microscopy_Images\');
path_and_file = [pathX fileX] ;
%load the file into a data variable
data = load(path_and_file);

%the order of the butter filter
order_filter = 10;
%the normalized cut off frequency for the butter filter
Cutoff_freq = 0.1;

FilmStress = data.FilmStress; %stress in num_films films as a function of time
time_temp = data.time;  %time vector generated during stress/xproj calculations

%ignore the last time point because it has always stress at zero - an artifact of data aquisition
time = time_temp(1:(length(time_temp)-1));
num_films = data.num_films; %number of films
frame_rate = data.frame_rate; %frame rate of the original movie
t = (1:1:length(time))'; %time counter

for filmcount = 1:num_films %cycle through each film
    %asign a single film stress to the cell_stress function, ignore the
    %last time point because it has always stress at zero - an artifact of
    %data aquisition
    cell_stress = FilmStress(1:length(time),filmcount); %stress for the specific film
    cell_stress = (cell_stress>0).*cell_stress; %take only positive stress, set others to zero
    
    %set the startpoint of the analysis for the second time point, and end
    %two prior - this is dones to simplify calculations and does not impact
    %analysis.
    startpoint = 2;
    endpoint = length(time)-2;
    
    %Generate the filter
    [b,a] = butter(order_filter,Cutoff_freq);
    %Filter out the noise from the data
    new_stress = filtfilt(b,a,cell_stress);
    
    %initilize count variables
    count_ext = 0; %count the number of extrema
    count_sys = 0; %count number of peak systole (i.e. maximal stress)
    count_dys = 0; %count number of minimums
    
    %The diffstress is the difference between
    %new_stress(i+1)-new_stress(i), i.e. it is negative in decreasing
    %sections and positive in increasing
    diffstress = diff(new_stress);
    
    %cycle through the relevant time points
    for i = startpoint:endpoint
        
        %If diffstress(i) >=0 and diffstress(i-1)<0 there is a minimum
        %either at i or in between i and i-1, estimate that it is at i
        if diffstress(i) >= 0 && diffstress(i-1) < 0
            %increase the counter of the extrema and end systole to include the new minimum
            count_ext = count_ext+1;
            count_dys = count_dys+1;
            
            %Store the stress value at the extremum
            ext_val(count_ext) = new_stress(i);
            %store the placement of the extremum
            ext_i(count_ext) = i;
            
            %store the value of the placement of a minimum
            dys_i(count_dys) = ext_i(count_ext);
            %store the value of the minimal stress
            dys_stress(count_dys) = ext_val(count_ext);
        end
        
        %If diffstress(i) <= 0 and diffstress(i-1) > 0 there is a maximum
        %either at i or in between i and i-1, estimate that it is at i
        if diffstress(i) <= 0 && diffstress(i-1) > 0
            %increase the counter of the extrema and end systole to include
            %the new maximum
            count_ext = count_ext+1;
            count_sys = count_sys+1;
            
            %Store the stress value at the extremum
            ext_val(count_ext) = new_stress(i);
            %store the placement of the extremum
            ext_i(count_ext) = i;
            
            %store the value of the placement of a maximum
            sys_i(count_sys) = ext_i(count_ext);
            %store the value of the maximal stress
            sys_stress(count_sys) = ext_val(count_ext);
        end
    end
    
    %Determine if a maximum (peak systole) was first or a minimum (min dys)
    if sys_i(1) < dys_i(1)
        %fall time
        fall_time = dys_i(1:count_dys) - sys_i(1:count_dys);
        %rise time
        rise_time = sys_i(2:count_sys) - dys_i(1:(count_sys-1));
        %peak contraction stress
        peak_cont_stress = sys_stress(2:count_sys) - dys_stress(1:(count_sys-1));
    else %if the minimum was first
        %fall time
        fall_time = dys_i(2:count_dys) - sys_i(1:(count_dys-1));
        %rise time
        rise_time = sys_i(1:count_sys) - dys_i(1:count_sys);
        %peak contraction stress
        peak_cont_stress = sys_stress(1:count_sys) - dys_stress(1:count_sys);
    end
    
    %period for each peak
    period = diff(dys_i);
    %frequency at each peak
    freq = 1./period;
    
    
    % Makes sure that stresses are not affected by noise (DL edit from 
    % Jeff's modified code)
    % It loops through the peak stress values and time values to guarantee
    % that second bumps (due to problems in contraction or noise in the
    % image/post-processed data) do not atificially reduce the computed
    % values.
    for k = 1:length(peak_cont_stress)
        if peak_cont_stress(k)<0.95*max(peak_cont_stress)
            peak_cont_stress(k) = 0;
        end
    end
    peak_cont_stress = peak_cont_stress(peak_cont_stress ~=0);
    
    for k = 1:length(rise_time)
        if rise_time(k)<0.95*max(rise_time)
            rise_time(k) = 0;
        end
    end
    rise_time = rise_time(rise_time ~=0);
    
    for k = 1:length(fall_time)
        if fall_time(k)<0.95*max(fall_time)
            fall_time(k) = 0;
        end
    end
    fall_time = fall_time(fall_time ~=0);

    
    figure(1)
    hold on
    subplot(num_films,2,2*(filmcount-1)+1)
    plot(t(1:end),new_stress,ext_i,ext_val,'o')
    subplot(num_films,2,2*(filmcount-1)+2)
    plot(t(1:end),cell_stress,t(1:end),new_stress,'r')
    
    %basal stress - the minimum of the minima extrema
    basal_stress(filmcount) = min(dys_stress);
    %average rise time in time units
    mean_rise_time(filmcount) = mean(rise_time)./frame_rate;
    %average fall time in time units
    mean_fall_time(filmcount) = mean(fall_time)./frame_rate;
    %average peak contraction stress
    mean_peak_cont_stress(filmcount) = mean(peak_cont_stress);
    %Normalized stress
    cont_stress(:,filmcount) = new_stress - basal_stress(filmcount).*ones(size(new_stress));
    
end
hold off

filename_analyzed = [pathX fileX(1:(length(fileX)-4)) '_analyzed.mat'];

save(filename_analyzed,'FilmStress','time','num_films','frame_rate','path_and_file','basal_stress','mean_rise_time','mean_fall_time','mean_peak_cont_stress','cont_stress')